// File: ArbitrageExecutor.huff
// Version: 1.1 (Optimized with Callback Amount Capture & Withdrawal)
// Purpose: Gas-optimized Uniswap V3 2-way arbitrage executor for Balancer V2 flash loans.

// =======================================================
// Imports & Constants
// =======================================================

// Function Selectors
#define constant APPROVE_SELECTOR = 0x095ea7b3
#define constant SWAP_SELECTOR = 0x022c0d9f
#define constant TRANSFER_SELECTOR = 0xa9059cbb
#define constant BALANCE_OF_SELECTOR = 0x70a08231 // Still needed for withdrawal check

// Flash Loan Related Constants
#define constant RECEIVE_FLASH_LOAN_SELECTOR = 0xf3f18ace
#define constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C9 // Balancer V2 Vault
#define constant RECEIVE_FLASH_LOAN_RETURN_VALUE = 0xa157427a8d45e187257fa91ff98f73367a3e04075e180055503bf726067157a9 // keccak256("ERC3156FlashBorrower.onFlashLoan")

// Uniswap V3 Callback Selector
#define constant UNISWAP_V3_SWAP_CALLBACK_SELECTOR = 0xfa461e33

// TickMath constants for sqrtPriceLimitX96
#define constant MIN_SQRT_RATIO = 0x4295128739
#define constant MAX_SQRT_RATIO = 0x1461446703485210103287273052203988822378723970342

// Withdrawal Function Selector
#define constant WITHDRAW_TOKEN_SELECTOR = 0x01e3b41a // Simplified selector for withdrawToken(address,address)

// Storage Slots (using constants for clarity)
#define constant OWNER_SLOT = 0x00 // Slot 0 for owner address

// Memory Pointers / Layout Markers
// Note: These are conceptual markers, actual memory use is dynamic.
#define constant MEM_TEMP_SPACE_START = 0x00   // General scratch space
#define constant MEM_RECEIVED_AMOUNT_SLOT = 0x60 // Temp storage for amount received in callback
#define constant MEM_CALLBACK_DATA_START = 0x80  // Buffer for callback data (token0, token1)
#define constant MEM_EXTERNAL_CALL_BUFFER = 0x100 // Buffer for swap/approve calldata

// =======================================================
// Interface Definitions (for clarity)
// =======================================================
//#define function receiveFlashLoan(address[],uint256[],uint256[],bytes) view returns (bytes32)
//#define function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) nonpayable
//#define function withdrawToken(address token, address recipient) nonpayable

// =======================================================
// Constructor Macro (Sets Immutable Owner)
// =======================================================
// This macro runs ONLY during deployment.
#define macro CONSTRUCTOR() = takes(0) returns (0) {
    // Copy the deployer's address from calldata
    // Assumes deployer address is appended to creation code (standard proxy pattern)
    // Or simply use caller() if deployed directly by owner EOA
    caller                     // [deployer_address]
    [OWNER_SLOT]               // [OWNER_SLOT, deployer_address]
    sstore                     // Store deployer_address in storage slot 0
    stop                       // End constructor execution
}

// =======================================================
// Uniswap V3 Swap Callback Macro
// =======================================================
// @notice Handles payment requested by the Uniswap V3 pool during a swap.
//         Crucially, it stores the amount received into memory slot MEM_RECEIVED_AMOUNT_SLOT.
#define macro UNISWAP_V3_SWAP_CALLBACK() = takes(0) returns (0) {
    // Calldata offsets (relative to start of arguments, after selector)
    #define cd_amount0Delta 0x04
    #define cd_amount1Delta 0x24
    #define cd_dataPtr      0x44

    // Load deltas
    [cd_amount0Delta] calldataload // [amount0Delta]
    [cd_amount1Delta] calldataload // [amount1Delta, amount0Delta]

    // Check if Token0 needs to be paid (amount0Delta < 0)
    dup1 0x00 gt pay_token1 jumpi // If amount0Delta > 0, we received token0, jump to pay_token1 logic

    // --- Pay Token 0 ---
    // Calculate amount owed = -amount0Delta
    0x00 swap1 sub     // [-amount0Delta, amount1Delta] (amount_to_pay)

    // Store the POSITIVE amount received (amount1Delta) in memory
    swap1 [MEM_RECEIVED_AMOUNT_SLOT] mstore // Store amount1Delta, stack: [amount_to_pay]

    // Load token0 address from callback data (data starts after selector & length)
    [cd_dataPtr] calldataload 0x24 add calldataload // [token0_addr, amount_to_pay]

    // Prepare token0.transfer(pool, amount_to_pay) calldata in buffer
    [TRANSFER_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    caller()            [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore
    swap1               [MEM_EXTERNAL_CALL_BUFFER + 0x24] mstore // [token0_addr] amount_to_pay at offset 0x24

    // Execute transfer
    0x00 0x00 0x44 [MEM_EXTERNAL_CALL_BUFFER] 0x00 swap1 gas call // [success] Target=token0_addr
    iszero revert_if_zero // Revert if transfer failed
    stop // Payment successful, callback finished

pay_token1:
    // Stack: [amount1Delta, amount0Delta > 0]
    // amount0Delta > 0 means we received Token0. Store it.
    [MEM_RECEIVED_AMOUNT_SLOT] mstore // Store amount0Delta, stack: [amount1Delta]

    // Check if Token1 needs to be paid (amount1Delta < 0)
    dup1 0x00 gt callback_end jumpi // If amount1Delta > 0, we received token1, callback is done.

    // --- Pay Token 1 ---
    // Calculate amount owed = -amount1Delta
    0x00 swap1 sub // [-amount1Delta] (amount_to_pay)

    // Load token1 address from callback data (token1 is at offset 32 in data)
    [cd_dataPtr] calldataload 0x24 add 0x20 add calldataload // [token1_addr, amount_to_pay]

    // Prepare token1.transfer(pool, amount_to_pay) calldata in buffer
    [TRANSFER_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    caller()            [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore
    swap1               [MEM_EXTERNAL_CALL_BUFFER + 0x24] mstore // [token1_addr] amount_to_pay at offset 0x24

    // Execute transfer
    0x00 0x00 0x44 [MEM_EXTERNAL_CALL_BUFFER] 0x00 swap1 gas call // [success] Target=token1_addr
    iszero revert_if_zero // Revert if transfer failed

callback_end:
    stop // Callback finished

revert_if_zero: // Reusable revert check
    iszero iszero jumpi // Jump past revert if success was non-zero
    0x00 0x00 revert
}


// =======================================================
// Flash Loan Receiver Macro
// =======================================================
// @notice Main logic executed when Balancer calls back after providing the loan.
#define macro RECEIVE_FLASH_LOAN() = takes(0) returns (0) {

    // --- Memory Map Reminder ---
    // 0x00: loan_amount
    // 0x20: fee_amount
    // 0x40: token0 address
    // 0x60: MEM_RECEIVED_AMOUNT_SLOT (stores amount out from swap1/callback)
    // --- UserData Params (Loaded temporarily below) ---
    // pool_A, pool_B, token1, zeroForOne_swap1
    // --- Buffers ---
    // MEM_CALLBACK_DATA_START onwards: Callback data (token0, token1)
    // MEM_EXTERNAL_CALL_BUFFER onwards: External call calldata (swap, approve)

    // --- 1. Load Loan Parameters & User Data ---
    // Load Loan Amount, Fee Amount, Token0 Address into memory [0x00-0x60]
    0x24 calldataload 0x20 add calldataload 0x00 mstore // loan_amount
    0x44 calldataload 0x20 add calldataload 0x20 mstore // fee_amount
    0x04 calldataload 0x20 add calldataload 0x40 mstore // token0

    // Load UserData parameters (PoolA, PoolB, Token1, zeroForOne_swap1)
    // We'll load them onto the stack temporarily for use
    0x64 calldataload // [userData_offset]
    dup1 0x24 add calldataload // [pool_A, userData_offset]
    dup1 0x44 add calldataload swap1 pop // [pool_B, pool_A, userData_offset]
    dup1 0x64 add calldataload swap1 pop // [token1, pool_B, pool_A, userData_offset]
    dup1 0x84 add calldataload swap1 pop // [zeroForOne_swap1, token1, pool_B, pool_A, userData_offset]
    pop // Pop final userData_offset
    // Stack: [zeroForOne_swap1, token1, pool_B, pool_A]

    // --- 2. Perform Swap 1 (token0 -> token1 or vice-versa on Pool A) ---
    // Prepare sqrtPriceLimitX96 for swap1 based on zeroForOne_swap1
    dup1 iszero set_min_sqrt1 jumpi       // Check zeroForOne flag
    [MAX_SQRT_RATIO] sqrt_limit_set1 jump // Set max limit
    set_min_sqrt1: [MIN_SQRT_RATIO] 0x01 add
    sqrt_limit_set1: // [sqrt_limit, zeroForOne_swap1, token1, pool_B, pool_A]

    // Prepare callback data (token0, token1) in memory buffer
    0x40 mload [MEM_CALLBACK_DATA_START] mstore          // Store token0
    dup4      [MEM_CALLBACK_DATA_START + 0x20] mstore    // Store token1 (it's 4th on stack)

    // Prepare calldata for pool_A.swap(...) in external call buffer
    [SWAP_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    address()       [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore // recipient = this contract
    dup1            [MEM_EXTERNAL_CALL_BUFFER + 0x24] mstore // zeroForOne flag (5th on stack)
    0x00 mload      [MEM_EXTERNAL_CALL_BUFFER + 0x44] mstore // amountSpecified (loan_amount)
    swap1           [MEM_EXTERNAL_CALL_BUFFER + 0x64] mstore // sqrtPriceLimit (was top)
    // Stack: [zeroForOne_swap1, token1, pool_B, pool_A]
    0x80            [MEM_EXTERNAL_CALL_BUFFER + 0x84] mstore // Offset to callback data (relative to start of args)= 5*32=160=0xA0?? NO! Relative to MEM_EXTERNAL_CALL_BUFFER+4
                                                              // Let's re-calculate: Args start at +4. Need space for 5 args (160 bytes). Data offset is 160 = 0xA0.
                                                              // Offset field value should be 0xA0. Stored at +0x84 relative to buffer start.
    // Callback data length & content in buffer
    0x40            [MEM_EXTERNAL_CALL_BUFFER + 0xA4] mstore // Callback data Length (64 bytes)
    [MEM_CALLBACK_DATA_START] mload [MEM_EXTERNAL_CALL_BUFFER + 0xC4] mstore // Callback data[0] (token0)
    [MEM_CALLBACK_DATA_START + 0x20] mload [MEM_EXTERNAL_CALL_BUFFER + 0xE4] mstore // Callback data[1] (token1)

    #define SWAP1_CALLDATA_SIZE 0x104 // 4 selector + 5 args (160) + data offset (32) + data length (32) + data (64) = 292 = 0x124. NO, size is size of CALLDATA, not buffer structure.
                                      // Calldata = selector + args = 4 + 5*32 + offset_arg + data_len + data = 4 + 160 + 32 + 32 + 64 = 292 = 0x124
                                      // The `swap` function signature defines the layout. Offset points within calldata.
                                      // Calldata: selector(4) + recipient(32) + zeroForOne(32) + amount(32) + limit(32) + dataOffset(32) + dataLen(32) + data(N)
                                      // Here N=64. Total = 4+5*32+32+64 = 4+160+32+64 = 260 = 0x104. Correct.

    // Execute pool_A.swap(...)
    // Stack: [zeroForOne_swap1, token1, pool_B, pool_A]
    swap3 // [pool_A, token1, pool_B, zeroForOne_swap1]
    0x00 0x00 [SWAP1_CALLDATA_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00 swap1 gas call // [success, token1, pool_B, zeroForOne_swap1]
    iszero revert_if_zero // Revert if swap1 call failed

    // --- 3. Perform Swap 2 (Received token -> token0 on Pool B) ---
    // Swap 1 was successful. The amount received (token1 or token0) is now stored in MEM_RECEIVED_AMOUNT_SLOT by the callback.

    // Prepare zeroForOne_swap2 flag (opposite of swap1)
    iszero // [zeroForOne_swap2, token1, pool_B]

    // Prepare sqrtPriceLimitX96 for swap2
    dup1 iszero set_min_sqrt2 jumpi       // Check zeroForOne_swap2 flag
    [MAX_SQRT_RATIO] sqrt_limit_set2 jump // Set max limit
    set_min_sqrt2: [MIN_SQRT_RATIO] 0x01 add
    sqrt_limit_set2: // [sqrt_limit2, zeroForOne_swap2, token1, pool_B]

    // Callback data buffer (MEM_CALLBACK_DATA_START) still holds token0, token1 needed for callback

    // Prepare calldata for pool_B.swap(...) in external call buffer
    [SWAP_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    address()       [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore
    dup1            [MEM_EXTERNAL_CALL_BUFFER + 0x24] mstore // zeroForOne_swap2 flag (3rd on stack)
    [MEM_RECEIVED_AMOUNT_SLOT] mload [MEM_EXTERNAL_CALL_BUFFER + 0x44] mstore // amountSpecified (received from swap1)
    swap1           [MEM_EXTERNAL_CALL_BUFFER + 0x64] mstore // sqrtPriceLimit2 (was top)
    // Stack: [zeroForOne_swap2, token1, pool_B]
    0xA0            [MEM_EXTERNAL_CALL_BUFFER + 0x84] mstore // Offset to callback data (same structure)

    // Callback data length & content already prepared in buffer for swap 1, reused here.

    #define SWAP2_CALLDATA_SIZE 0x104 // Same size structure

    // Execute pool_B.swap(...)
    // Stack: [zeroForOne_swap2, token1, pool_B]
    swap2 // [pool_B, token1, zeroForOne_swap2]
    0x00 0x00 [SWAP2_CALLDATA_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00 swap1 gas call // [success, token1, zeroForOne_swap2]
    iszero revert_if_zero // Revert if swap2 call failed

    // --- 4. Approve Balancer Vault for Repayment ---
    // Swaps completed successfully. Approve loan_amount + fee_amount of token0.
    0x20 mload 0x00 mload add // [repayment_amount] (loan + fee)

    // Prepare token0.approve(BALANCER_VAULT, repayment_amount) calldata
    [APPROVE_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    [BALANCER_VAULT]   [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore
    swap1              [MEM_EXTERNAL_CALL_BUFFER + 0x24] mstore // repayment_amount

    #define APPROVE_CALLDATA_SIZE 0x44 // 4 + 32 + 32 = 68 bytes = 0x44

    // Execute approve
    0x00 0x00 [APPROVE_CALLDATA_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00 0x40 mload gas call // [success] Target=token0
    iszero revert_if_zero // Revert if approve failed

    // --- 5. Final Return to Balancer ---
    // Signal successful execution of the flash loan terms
    [RECEIVE_FLASH_LOAN_RETURN_VALUE] [MEM_TEMP_SPACE_START] mstore
    0x20 [MEM_TEMP_SPACE_START] return // Return success code
}


// =======================================================
// Profit Withdrawal Macro
// =======================================================
// @notice Allows the owner to withdraw accumulated profit of a specific token.
#define macro WITHDRAW_TOKEN() = takes(0) returns (0) {
    // --- Check Ownership ---
    caller [OWNER_SLOT] sload eq is_owner jumpi // Revert if caller is not owner
    0x00 0x00 revert // Not owner revert

is_owner:
    // --- Load Parameters ---
    // Calldata: selector(4) + token_addr(32) + recipient_addr(32)
    0x04 calldataload // [token_addr]
    0x24 calldataload // [recipient_addr, token_addr]

    // --- Get Contract's Balance of Token ---
    // Prepare balanceOf(address(this)) calldata
    [BALANCE_OF_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    address() [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore
    #define WITHDRAW_BALANCEOF_SIZE 0x24

    // Call balanceOf - use temporary memory for return value
    0x20 [MEM_TEMP_SPACE_START] [WITHDRAW_BALANCEOF_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00 dup3 staticcall // [success, recipient_addr, token_addr] (target=token_addr)
    iszero revert_if_zero // Revert if balanceOf failed

    // Load balance from memory
    [MEM_TEMP_SPACE_START] mload // [balance, recipient_addr, token_addr]

    // --- Transfer Balance to Recipient ---
    // Prepare transfer(recipient, balance) calldata
    [TRANSFER_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    swap1 swap2 // [token_addr, balance, recipient_addr]
    [MEM_EXTERNAL_CALL_BUFFER + 0x04] mstore // recipient
    swap1 // [balance, token_addr]
    [MEM_EXTERNAL_CALL_BUFFER + 0x24] mstore // balance

    // Execute transfer
    #define WITHDRAW_TRANSFER_SIZE 0x44
    0x00 0x00 [WITHDRAW_TRANSFER_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00 swap1 gas call // [success] Target=token_addr
    iszero revert_if_zero // Revert if transfer failed

    stop // Withdrawal successful
}


// =======================================================
// Main Dispatcher Macro (Contract Entry Point)
// =======================================================
#define macro MAIN() = takes(0) returns (0) {
    // Identify function called via selector
    0x00 calldataload 0xE0 shr

    // Route to appropriate macro
    dup1 [RECEIVE_FLASH_LOAN_SELECTOR] eq receive_flash_loan jumpi
    dup1 [UNISWAP_V3_SWAP_CALLBACK_SELECTOR] eq swap_callback jumpi
    dup1 [WITHDRAW_TOKEN_SELECTOR] eq withdraw_token jumpi

    // Revert if selector doesn't match known functions
    0x00 0x00 revert

    // --- Function Jump Targets ---
receive_flash_loan:
    RECEIVE_FLASH_LOAN()

swap_callback:
    UNISWAP_V3_SWAP_CALLBACK()

withdraw_token:
    WITHDRAW_TOKEN()
}