// File: ArbitrageExecutor.huff
// Version: 2.3.0 (Added Salt Nonce Guard)
// Purpose: Gas-optimized Cross-DEX (UniV3/VeloV2) 2-way arbitrage executor
//          with on-chain MINIMUM profit check, salt nonce guard, and debug logging.

// =======================================================
// Imports & Constants
// =======================================================

// Function Selectors
#define constant APPROVE_SELECTOR = 0x095ea7b3
#define constant TRANSFER_SELECTOR = 0xa9059cbb
#define constant BALANCE_OF_SELECTOR = 0x70a08231
#define constant UNISWAP_V3_SWAP_SELECTOR = 0x022c0d9f
#define constant VELODROME_SWAP_SELECTOR = 0x38ed1739
#define constant RECEIVE_FLASH_LOAN_SELECTOR = 0xf3f18ace
#define constant UNISWAP_V3_SWAP_CALLBACK_SELECTOR = 0xfa461e33
#define constant WITHDRAW_TOKEN_SELECTOR = 0x01e3b41a

// Addresses
#define constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C9

// Return Value
#define constant RECEIVE_FLASH_LOAN_RETURN_VALUE = 0xa157427a8d45e187257fa91ff98f73367a3e04075e180055503bf726067157a9

// UniV3 Constants
#define constant MIN_SQRT_RATIO = 0x4295128739
#define constant MAX_SQRT_RATIO = 0x1461446703485210103287273052203988822378723970342

// Storage Slots
#define constant OWNER_SLOT = 0x00
#define constant SALT_SEEN_MAPPING_SLOT = 0x01 // Base slot for mapping(uint256 => uint256)

// Memory Pointers / Layout
#define constant MEM_TEMP_SPACE_START = 0x00    // General temp space for return data etc.
#define constant MEM_LOAN_AMOUNT = 0x00         // Location within temp space (reused)
#define constant MEM_FEE_AMOUNT = 0x20          // Location within temp space (reused)
#define constant MEM_TOKEN0_ADDR = 0x40        // Loan token addr (persistent location)
#define constant MEM_RECEIVED_AMOUNT_SLOT = 0x60 // Stores amount received from Swap1
#define constant MEM_CALLBACK_DATA_START = 0x80 // Buffer for UniV3 callback data
#define constant MEM_PATH_ARRAY_START = 0xC0    // Buffer for Velo path array
#define constant MEM_FINAL_BALANCE_SLOT = 0xE0  // Temp storage for final balance check
#define constant MEM_MIN_PROFIT_SLOT = 0x100    // Stores minProfitWei from userData
#define constant MEM_SALT_SLOT = 0x120          // **NEW**: Stores salt from userData
#define constant MEM_KECCAK_INPUT_START = 0x140 // **NEW**: Temp space for keccak input
#define constant MEM_EXTERNAL_CALL_BUFFER = 0x180 // **SHIFTED**: Main buffer for external calls

// Call Data Sizes
#define constant UNISWAP_SWAP_CALLDATA_SIZE = 0x104
#define constant VELODROME_SWAP_CALLDATA_SIZE = 0xE4
#define constant APPROVE_CALLDATA_SIZE = 0x44
#define constant BALANCEOF_CALLDATA_SIZE = 0x24
#define constant TRANSFER_CALLDATA_SIZE = 0x44
#define constant WITHDRAW_BALANCEOF_SIZE = 0x24
#define constant WITHDRAW_TRANSFER_SIZE = 0x44

// Debug Logging Topic
#define constant DEBUG_LOG_TOPIC = 0xdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd

// =======================================================
// Macros (CONSTRUCTOR, UNISWAP_V3_SWAP_CALLBACK, PREPARE_VELO_PATH unchanged)
// =======================================================
#define macro CONSTRUCTOR() = takes(0) returns (0) { /* ... unchanged ... */ }
#define macro UNISWAP_V3_SWAP_CALLBACK() = takes(0) returns (0) { /* ... unchanged ... */ }
#define macro PREPARE_VELO_PATH() = takes(2) returns(0) { /* ... unchanged ... */ }

// =======================================================
// Flash Loan Receiver Macro
// =======================================================
#define macro RECEIVE_FLASH_LOAN() = takes(0) returns (0) {

    // --- 1. Load Loan Parameters & User Data ---
    0x44 calldataload calldataload [MEM_LOAN_AMOUNT] mstore
    0x00 [MEM_FEE_AMOUNT] mstore
    0x24 calldataload calldataload [MEM_TOKEN0_ADDR] mstore

    // UserData Structure starts at offset 0x64
    // ... (offsets 0x00 to 0xC0 as before) ...
    // 0xE0: minProfitWei (uint256)
    // 0x100: salt (uint256)  ** NEW **
    0x64 calldataload // userData_ptr offset
    // Load salt first for guard check
    dup1 0x100 add calldataload [MEM_SALT_SLOT] mstore // Load salt
    // Load minProfitWei
    dup1 0xE0 add calldataload [MEM_MIN_PROFIT_SLOT] mstore // Load minProfitWei
    // Load other userData into stack
    dup1 calldataload     // pool_A
    dup1 0x20 add calldataload // pool_B
    dup1 0x40 add calldataload // token1
    dup1 0x60 add calldataload // zeroForOne_A
    dup1 0x80 add calldataload // is_A_Velo
    dup1 0xA0 add calldataload // is_B_Velo
    dup1 0xC0 add calldataload // velo_router
    // Clean stack: remove ptrs and extra salt/minprofit copies
    swap8 pop swap7 pop swap6 pop // Remove vr, isB, isA, zfoA, t1, pB, pA, ptr, ptr
    // Stack: [vr, isB, isA, zfoA, token1, pool_B, pool_A] (7 items)

    // --- 1b. Salt Nonce Guard ---
    // Calculate storage key for the salt in the mapping: keccak256(salt, MAPPING_SLOT)
    [MEM_SALT_SLOT] mload            // [salt]
    [MEM_KECCAK_INPUT_START] mstore  // Store salt in memory for hashing
    [SALT_SEEN_MAPPING_SLOT]         // [mapping_slot_num, salt]
    [MEM_KECCAK_INPUT_START] 0x20 add mstore // Store mapping slot number after salt
    // Stack is now empty
    // Hash the 64 bytes (salt + slot_num) in memory
    [MEM_KECCAK_INPUT_START]         // offset
    0x40                             // size = 32 bytes salt + 32 bytes slot = 64 bytes
    keccak256                        // [storage_key]
    // Check if this storage key has a non-zero value
    dup1                             // [storage_key, storage_key]
    sload                            // [value, storage_key]
    iszero                           // [is_zero (1 if not seen, 0 if seen)]
    revert_if_salt_seen jumpi        // If value was non-zero (is_zero is 0), jump to revert
    // Salt not seen, mark it as seen by storing 1
    push1 0x01                       // [1, storage_key]
    sstore                           // Mark as seen. Stack is now empty.

    // --- Log Entry Point & Loan Amount ---
    [MEM_LOAN_AMOUNT] mload [DEBUG_LOG_TOPIC] log1

    // --- 2. Perform Swap 1 ---
    // (Logic for Swap 1 UniV3/VeloV2 remains the same, using MEM_EXTERNAL_CALL_BUFFER which is now shifted)
    // ... Swap 1 Velo/Uni logic ...
    // Stack entering Swap 2 logic should still be normalized: [vr, pB, t1, zfoA, isB]

    // --- 3. Perform Swap 2 ---
    // (Logic for Swap 2 UniV3/VeloV2 remains the same)
    // ... Swap 2 Velo/Uni logic ...
    // Stack cleanup after swap 2

    // --- 4. Profit / Slippage Check (with minProfitWei) ---
    // Get final balance of token0
    [BALANCE_OF_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    address [MEM_EXTERNAL_CALL_BUFFER] 0x04 add mstore
    0x20 [MEM_FINAL_BALANCE_SLOT] [BALANCEOF_CALLDATA_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00
    [MEM_TOKEN0_ADDR] mload gas staticcall iszero revert_if_zero

    // Load values for check: final_balance >= loan + fee(0) + min_profit
    [MEM_FINAL_BALANCE_SLOT] mload // [final_balance]
    [MEM_FEE_AMOUNT] mload         // [fee, final_balance]
    [MEM_LOAN_AMOUNT] mload add    // [loan_plus_fee, final_balance]
    [MEM_MIN_PROFIT_SLOT] mload add // [required_return = loan + fee(0) + min_profit, final_balance]

    // Log Final Balance & Required Return
    dup1 [DEBUG_LOG_TOPIC] log1
    dup2 [DEBUG_LOG_TOPIC] log1

    // Check: final_balance >= required_return (Changed from GT to GTE)
    dup1 swap2 lt // is final < required? [is_less_than, required_return]
    revert_if_unprofitable jumpi // If final < required (is_less_than is 1), jump to revert

    // --- 5. Approve Balancer Vault Repayment (Loan + Fee) ---
    // Profit check passed
    [MEM_FEE_AMOUNT] mload [MEM_LOAN_AMOUNT] mload add // [repayment_amount = loan + fee]
    [APPROVE_SELECTOR] [MEM_EXTERNAL_CALL_BUFFER] mstore
    [BALANCER_VAULT] [MEM_EXTERNAL_CALL_BUFFER] 0x04 add mstore
    dup1 [MEM_EXTERNAL_CALL_BUFFER] 0x24 add mstore
    0x00 0x00 [APPROVE_CALLDATA_SIZE] [MEM_EXTERNAL_CALL_BUFFER] 0x00
    [MEM_TOKEN0_ADDR] mload gas call iszero revert_if_zero

    // --- 6. Final Return to Balancer ---
    [RECEIVE_FLASH_LOAN_RETURN_VALUE] [MEM_TEMP_SPACE_START] mstore
    0x20 [MEM_TEMP_SPACE_START] return

revert_if_salt_seen:
    // Optional: Log specific revert reason?
    0x00 0x00 revert // Revert if salt already seen

revert_if_unprofitable:
    0x00 [DEBUG_LOG_TOPIC] log1 // Log 0 for profit failure
    0x00 0x00 revert
}


// =======================================================
// Profit Withdrawal Macro (Unchanged)
// =======================================================
#define macro WITHDRAW_TOKEN() = takes(0) returns (0) { /* ... unchanged ... */ }

// =======================================================
// Main Dispatcher Macro (Unchanged)
// =======================================================
#define macro MAIN() = takes(0) returns (0) { /* ... unchanged ... */ }